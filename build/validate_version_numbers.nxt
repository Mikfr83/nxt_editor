{
    "version": "1.16", 
    "alias": "validate_version_numbers", 
    "color": "#be6c00", 
    "mute": false, 
    "solo": false, 
    "references": [
        "GitUtils.nxt"
    ], 
    "meta_data": {
        "positions": {
            "/CheckoutMaster": [
                140.0, 
                0.0
            ], 
            "/CheckoutWorking": [
                840.0, 
                0.0
            ], 
            "/GitCmd": [
                -1600.0, 
                -200.0
            ], 
            "/GitCurBranch": [
                -1200.0, 
                -20.0
            ], 
            "/GitPR": [
                -1600.0, 
                -60.0
            ], 
            "/GitRelease": [
                -1600.0, 
                -280.0
            ], 
            "/GitStatus": [
                -1200.0, 
                -280.0
            ], 
            "/GitUpload": [
                -1600.0, 
                240.0
            ], 
            "/JsonLoad": [
                -1600.0, 
                60.0
            ], 
            "/ParseVersionJSON": [
                480.0, 
                0.0
            ], 
            "/ParseVersions": [
                460.0, 
                0.0
            ], 
            "/PreCheck": [
                -160.0, 
                0.0
            ], 
            "/ValidateVersion": [
                1140.0, 
                0.0
            ], 
            "/ValidateWorking": [
                -20.0, 
                120.0
            ], 
            "/init": [
                -240.0, 
                0.0
            ], 
            "/make_module_folder": [
                -1600.0, 
                160.0
            ]
        }, 
        "collapse": {
            "/CheckoutMaster/CheckoutMaster": false, 
            "/CheckoutMaster/GitPull": false, 
            "/CheckoutMaster/ValidateMaster": false, 
            "/CheckoutWorking/CheckoutWorking": true, 
            "/CheckoutWorking/ValidateWorking": true, 
            "/GitCurBranch": true, 
            "/GitStatus": true, 
            "/GitUpload": true, 
            "/ParseVersions": false, 
            "/make_module_folder": true
        }
    }, 
    "nodes": {
        "/": {
            "child_order": [
                "CheckCommits", 
                "ValidatePushed", 
                "CreateRelease", 
                "BeginPR", 
                "ParseGitReturn", 
                "ParseGitReturn2", 
                "GitCmd", 
                "GitCmd2", 
                "CheckoutMaster", 
                "JsonLoad2", 
                "BeginRelease", 
                "GitCurBranch2", 
                "CheckoutWorking", 
                "make_package", 
                "GenerateHotkeysMD", 
                "make_module_folder", 
                "UpdateMasterPR", 
                "GenerateChangelog", 
                "ParseVersionJSON", 
                "ValidateWorking", 
                "ParseVersions", 
                "ValidateVersion", 
                "init"
            ], 
            "attrs": {
                "API": {
                    "type": "NoneType", 
                    "value": "None"
                }, 
                "EDITOR": {
                    "type": "NoneType", 
                    "value": "None"
                }, 
                "GRAPH": {
                    "comment": "minor or hotfix", 
                    "type": "NoneType", 
                    "value": "None"
                }, 
                "branch": {
                    "comment": "Name of the head branch", 
                    "type": "NoneType"
                }, 
                "hotfix": {
                    "comment": "Will be set during the init, leave as False", 
                    "type": "bool", 
                    "value": "False"
                }, 
                "master_api_version": {
                    "comment": "Expected API version number", 
                    "type": "list", 
                    "value": "[0, 0, 0]"
                }, 
                "master_editor_version": {
                    "comment": "Expected EDITOR version number", 
                    "type": "list", 
                    "value": "[0, 0, 0]"
                }, 
                "master_graph_version": {
                    "comment": "Expected GRAPH version number", 
                    "type": "list", 
                    "value": "[0, 0]"
                }, 
                "release_types": {
                    "type": "dict", 
                    "value": "{'major':0, 'minor':1, 'hotfix':2}"
                }
            }, 
            "code": [
                "# Builtin", 
                "import subprocess", 
                "import json", 
                "# Internal", 
                "from nxt.constants import API_VERSION, GRAPH_VERSION", 
                "from nxt.ui.constants import EDITOR_VERSION", 
                "attrs = ('API', 'EDITOR', 'GRAPH')", 
                "for attr in attrs:", 
                "    val = getattr(self, attr)", 
                "    if val == 'None' or val is None:", 
                "        continue", 
                "    if not val.startswith((\"'\", \"\\\"\")):", 
                "        setattr(STAGE, attr, w(val))", 
                ""
            ]
        }, 
        "/CheckoutMaster": {
            "start_point": false, 
            "execute_in": "/init", 
            "child_order": [
                "CheckoutMaster", 
                "ValidateMaster", 
                "GitPull", 
                "ValidateUpToDate"
            ], 
            "enabled": true, 
            "comment": "Checks out master and makes sure your version number is incremented correctly against master.", 
            "code": [
                "print('Getting master...')", 
                ""
            ]
        }, 
        "/CheckoutMaster/CheckoutMaster": {
            "instance": "/GitCmd", 
            "child_order": [
                "ParseGitReturn"
            ], 
            "attrs": {
                "cmd_args": {
                    "value": "\"checkout\", \"master\""
                }
            }
        }, 
        "/CheckoutMaster/GitPull": {
            "instance": "/GitCmd", 
            "child_order": [
                "ParseGitReturn"
            ], 
            "attrs": {
                "cmd_args": {
                    "value": "\"pull\""
                }
            }
        }, 
        "/CheckoutMaster/GitPull/ParseGitReturn": {
            "attrs": {
                "allow_multi_line": {
                    "value": "True"
                }
            }
        }, 
        "/CheckoutMaster/ValidateMaster": {
            "instance": "/GitCurBranch", 
            "child_order": [
                "ValidateExactBranch"
            ], 
            "code": [
                ""
            ]
        }, 
        "/CheckoutMaster/ValidateMaster/CurBranch/ParseGitReturn": {
            "attrs": {
                "key": {
                    "value": "\"*\""
                }
            }
        }, 
        "/CheckoutMaster/ValidateMaster/ValidateExactBranch": {
            "enabled": true, 
            "attrs": {
                "exact_branch": {
                    "value": "'master'"
                }
            }, 
            "code": [
                "branch = ${../CurBranch/ParseGitReturn.result}", 
                "if branch != ${exact_branch}:", 
                "    raise Exception(\"Invalid branch '{}' is not ${exact_branch}\".format(branch))", 
                "print('Your current branch \"{}\" is valid!'.format(branch))"
            ]
        }, 
        "/CheckoutMaster/ValidateUpToDate": {
            "code": [
                "git_return = '\\n'.join(${../GitPull/ParseGitReturn.result})", 
                "if 'Updating' in git_return and 'Fast-forward' in git_return:", 
                "    print('Updating master')", 
                "    ", 
                "elif 'Already up to date.' in git_return or 'Already up-to-date':", 
                "    print('Master already up to date')", 
                "else:", 
                "    raise Exception('Failed to pull master!')", 
                ""
            ]
        }, 
        "/CheckoutWorking": {
            "start_point": false, 
            "execute_in": "/ParseVersions", 
            "child_order": [
                "CheckoutWorking", 
                "ValidateWorking"
            ], 
            "enabled": true
        }, 
        "/CheckoutWorking/CheckoutWorking": {
            "instance": "/GitCmd", 
            "attrs": {
                "cmd_args": {
                    "value": "\"checkout\", \"${branch}\""
                }
            }
        }, 
        "/CheckoutWorking/ValidateWorking": {
            "instance": "/GitCurBranch", 
            "child_order": [
                "ValidateExactBranch"
            ], 
            "code": [
                ""
            ]
        }, 
        "/CheckoutWorking/ValidateWorking/CurBranch/ParseGitReturn": {
            "attrs": {
                "key": {
                    "value": "\"*\""
                }
            }
        }, 
        "/CheckoutWorking/ValidateWorking/ValidateExactBranch": {
            "enabled": true, 
            "attrs": {
                "exact_branch": {
                    "value": "'${branch}'"
                }
            }, 
            "code": [
                "branch = ${../CurBranch/ParseGitReturn.result}", 
                "if branch != ${exact_branch}:", 
                "    raise Exception(\"Invalid branch '{}' is not ${exact_branch}\".format(branch))", 
                "print('Your current branch \"{}\" is valid!'.format(branch))"
            ]
        }, 
        "/ParseVersions": {
            "execute_in": "/CheckoutMaster", 
            "child_order": [
                "Parse_API_Version", 
                "Parse_EDITOR_Version"
            ]
        }, 
        "/ParseVersions/Parse_API_Version": {
            "instance": "/JsonLoad", 
            "execute_in": "/CheckoutMaster", 
            "child_order": [
                "ReadMasterVersions"
            ], 
            "attrs": {
                "file_path": {
                    "type": "raw", 
                    "value": "${file::../nxt/version.json}"
                }
            }
        }, 
        "/ParseVersions/Parse_API_Version/ReadMasterVersions": {
            "code": [
                "for version_name, version_numbers in self.file_data.items():", 
                "    if not isinstance(version_numbers, dict):", 
                "        continue", 
                "    version_number = []", 
                "    for version_typ in ('MAJOR', 'MINOR', 'PATCH'):", 
                "        version_num = version_numbers.get(version_typ)", 
                "        if not isinstance(version_num, int):", 
                "            continue", 
                "        version_number.append(version_num)", 
                "    attr_name = 'master_{}_version'.format(version_name.lower())", 
                "    setattr(STAGE, attr_name, version_number)"
            ]
        }, 
        "/ParseVersions/Parse_EDITOR_Version": {
            "instance": "../Parse_API_Version", 
            "attrs": {
                "file_path": {
                    "type": "raw", 
                    "value": "${file::../nxt/ui/version.json}"
                }
            }
        }, 
        "/ValidateVersion": {
            "execute_in": "/CheckoutWorking", 
            "code": [
                "# The index of the int that should incriment in the version num", 
                "version_data = {", 
                "'API': {'rel_type': ${/.API},", 
                "        'version': ${/.master_api_version},", 
                "        'actual': API_VERSION.VERSION_TUPLE},", 
                "'GRAPH': {'rel_type': ${/.GRAPH},", 
                "            'version': ${/.master_graph_version},", 
                "            'actual': GRAPH_VERSION.VERSION_TUPLE},", 
                "'EDITOR': {'rel_type': ${/.EDITOR},", 
                "            'version': ${/.master_editor_version},", 
                "            'actual': EDITOR_VERSION.VERSION_TUPLE}", 
                "            }", 
                "passed = True", 
                "for rel_cat, rel_dict in version_data.items():", 
                "    actual = rel_dict['actual']", 
                "    master = rel_dict['version']", 
                "    print master", 
                "    rel_type = rel_dict['rel_type']", 
                "    if rel_type is None:", 
                "        continue", 
                "    incriment_idx = self.release_types.get(rel_type)", 
                "    expected = master[:]", 
                "    expected[incriment_idx] += 1", 
                "    for i in range(incriment_idx+1, 3):", 
                "        print('resetting' + str(i))", 
                "        try:", 
                "            expected[i] = 0", 
                "        except IndexError:", 
                "            continue", 
                "    expected = tuple(expected)", 
                "    if expected != actual:", 
                "        passed = False", 
                "        print('Invlaid {} version number! Expected:{} Actual:{}'.format(rel_cat, expected, actual))", 
                "        continue", 
                "    version_str = '.'.join(str(i) for i in actual)", 
                "    version_info = [rel_cat, version_str]", 
                "    print('Pushing to STAGE: ', rel_cat, version_info)", 
                "    setattr(STAGE, rel_cat, version_info)", 
                "    print('{} version number {} is valid {}'.format(rel_cat, actual, rel_type))", 
                "if not passed:", 
                "    raise Exception('Invlaid version numbers detected! See log')", 
                "", 
                ""
            ]
        }, 
        "/init": {
            "start_point": true, 
            "code": [
                "rel_cats = (${/.API}, ${/.EDITOR}, ${/.GRAPH})", 
                "if not any(rel_cats):", 
                "    print(\"\"\"API: ${/.API}, EDITOR:${/.EDITOR}, GRAPH:${/.GRAPH}\"\"\")", 
                "    raise Exception('Unable to validate version numbers, no parameters provided!')", 
                "", 
                "for mode in rel_cats:", 
                "    if mode is None:", 
                "        continue", 
                "    if mode.lower() not in ('major', 'minor', 'hotfix'):", 
                "        raise Exception('Unknown release type \"{}\"'.format(mode))", 
                "if ${/.GRAPH} is not None and ${/.GRAPH}.lower() == 'hotfix':", 
                "    raise Exception('Cannot hotfix GRAPH versions!')", 
                "if not '${/.branch}':", 
                "    raise Exception('No working branch provided!')", 
                "STAGE.hotfix = True", 
                "hotfix_str = 'hotfix'", 
                "if ${API} and ${API} != hotfix_str:", 
                "    STAGE.hotfix = False", 
                "", 
                "if ${EDITOR} and ${EDITOR} != hotfix_str:", 
                "    STAGE.hotfix = False", 
                "    ", 
                "if ${GRAPH} and ${GRAPH} != hotfix_str:", 
                "    STAGE.hotfix = False", 
                "", 
                "# Debug tool", 
                "# for rel_cat, actual in (('API', (0, 1, 1)), ('EDITOR', (2, 0, 0)), ('GRAPH', (1, 15, 0))):", 
                "#     version_str = '.'.join(str(i) for i in actual)", 
                "#     version_info = [rel_cat, version_str]", 
                "#     print('Setting', rel_cat, version_str)", 
                "#     setattr(STAGE, rel_cat, version_info)"
            ]
        }
    }
}